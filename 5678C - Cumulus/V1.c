#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftFrontEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightFrontEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftRearEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  rightRearEncoder, sensorQuadEncoder)
#pragma config(Motor,  port2,           rightFront,    tmotorVex393_MC29, PIDControl, driveRight, encoderPort, dgtl3)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393_MC29, PIDControl, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port4,           rightRear,     tmotorVex393_MC29, PIDControl, driveRight, encoderPort, dgtl7)
#pragma config(Motor,  port5,           leftRear,      tmotorVex393_MC29, PIDControl, driveLeft, encoderPort, dgtl5)
#pragma config(Motor,  port6,           intake1,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           intake2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           shooterL,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           shooterR,      tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

///////////////////////////////////////////////////////////////////////////////////////
//                                                          												 //
//  Thank You Jordan Kiesel (Team 24 - Bots'N'Stuff) For Providing the X-Drive Code  //
//																																									 //
///////////////////////////////////////////////////////////////////////////////////////
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	wait1Msec(2000);
	bMotorReflected[port2] = 1;
	SensorValue[leftFrontEncoder] = 0;
	SensorValue[rightFrontEncoder] = 0;
	SensorValue[leftRearEncoder] = 0;
	SensorValue[rightRearEncoder] = 0;

	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
const tSensors kGyroPort = in1; // gyroscopic sensor port/name
bool doUseGyro = true; // enable gyroscopic sensor
float gyroOffset = 90.0; // degrees CCW from +x axis robot faces at gyro=0
void calibrateGyro()
{
	// completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[kGyroPort] = sensorNone;
	wait1Msec(1000);
	SensorType[kGyroPort] = sensorGyro; // reconfigure as sensorGyro
	wait1Msec(2000); // wait for calibration: ROBOT MUST STAY STILL

	SensorScale[kGyroPort] = 138; // adjust SensorScale to correct the scaling for your gyro
	SensorFullCount[kGyroPort] = 3599; // fix rollover to be "...3598, 3599, 0, 1..."
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
/*void errorLeft ()
{
motor[leftRear] = 127;
motor[leftFront] = 127;
motor[rightRear] = 100;
motor[rightFront] = 100;
}
void errorRight ()
{
motor[leftRear] = 100;
motor[leftFront] = 100;
motor[rightRear] = 127;
motor[rightFront] = 127;
}
void drive(int speed)
{	motor [leftFront] = speed;
motor [rightFront] = speed;
motor [leftRear] = speed;
motor [rightRear] = speed;
}
void rotateL(int speed)
{	motor [leftFront] = -speed;
motor [rightFront] = speed;
motor [leftRear] = -speed;
motor [rightRear] = speed;
}
void rotateR(int speed)
{	motor [leftFront] = speed;
motor [rightFront] = -speed;
motor [leftRear] = speed;
motor [rightRear] = -speed;
}*/

task autonomous()
{

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task userDriveHolo() {
	const TVexJoysticks kChY = Ch3; // y-axis joystick channel
	const TVexJoysticks kChX = Ch4; // x-axis joystick channel
	const TVexJoysticks kChR = Ch1; // rotation joystick channel
	const short kDelay = 25; // milliseconds for loop delay
	const ubyte kNumWheels = 4; // number of drive wheels
	const ubyte kNumMotorsPerWheel = 1; // max number of motors per wheel
	const tMotor kNone = -1; // used for indicating the lack of an additional motor
	const tMotor kMotorPort[kNumWheels][kNumMotorsPerWheel] = { // drive motor ports/names
		{leftFront, kNone}, // front-left
		{rightFront, kNone}, // front-right
		{leftRear, kNone}, // back-left
		{rightRear, kNone},  // back-right
	};
	word x,y,r;
	float gyro,radius,theta,a,b,wheelSpeed[kNumWheels],topSpeed;
	while (true)
	{// ==== collect joystick & sensor values ====
		x = vexRT[kChX]; // x component
		y = vexRT[kChY]; // y component
		r = vexRT[kChR]; // rotation
	gyro = gyroOffset + (doUseGyro ? SensorValue[kGyroPort]/10.0 : 0.0); // if using gyro, scale its value to degrees

		// ==== convert joystick values to polar ====
		radius = sqrt(pow(x,2) + pow(y,2)); // r = sqrt(x^2 + y^2)
		theta = atan2(y,x)*180.0/PI; // t = arctan(y/x) [converted from radians to degrees]

		theta -= gyro; // adjust for gyro angle

		// ==== calculate opposite-side speeds ====
		a = (cosDegrees(theta) - sinDegrees(theta))*radius; // front-left and back-right
		b = (cosDegrees(theta) + sinDegrees(theta))*radius; // front-right and back-left

		// ==== set speeds, including rotation ====
		wheelSpeed[0] = a + r; // front-left
		wheelSpeed[1] = b - r; // front-right
		wheelSpeed[2] = b + r; // back-left
		wheelSpeed[3] = a - r; // back-right

		// ==== normalize speeds ====
		topSpeed = 0.0;
		for(ubyte i=0; i<kNumWheels; i++)
			if(abs(wheelSpeed[i]) > topSpeed)
			topSpeed = abs(wheelSpeed[i]); // find highest desired speed
		if(topSpeed > 127.0)
			for(ubyte i=0; i<kNumWheels; i++)
			wheelSpeed[i] /= topSpeed/127.0; // downscale all speeds so none are above 127

		// ==== update motor powers ====
		for(ubyte i=0; i<kNumWheels; i++) // cycle through all wheels
			for(ubyte j=0; j<kNumMotorsPerWheel; j++) // cycle through all motors for each wheel
			if(kMotorPort[i][j] != kNone) // check existence of motor
			motor[kMotorPort[i][j]] = (word)wheelSpeed[i]; // update motor power

		wait1Msec(kDelay);
	}
}
///////////////////////////////////////////////
void setShooter (int x)
{
	motor[shooterL] = motor[shooterR] = x;
}

task usercontrol()
{
	// User control code here, inside the loop

	calibrateGyro();//Might need to go to Pre-Auton
	startTask(userDriveHolo);
	while(true)
	{
		int shooter = vexRT[Btn8D];

		setShooter(shooter*127);

	}

	//In Case this (^) crap doesn't work. Use This
	/*
	motor[frontRight] = vexRT[Ch2] - vexRT[Ch1];
	motor[backRight] =  vexRT[Ch2] + vexRT[Ch1];
	motor[backLeft] = vexRT[Ch3] - vexRT[Ch4];
	motor[frontLeft] =  vexRT[Ch3] + vexRT[Ch4];
	*/
}
