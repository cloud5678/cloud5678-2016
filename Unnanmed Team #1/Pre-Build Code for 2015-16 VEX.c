#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    accelerometer,  sensorAccelerometer)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           rightFront,    tmotorVex393_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port4,           rightRear,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftRear,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

///////////////////////////////////////////////////////////////////////////////////////
//                                                          												 //
//  Thank You Jordan Kiesel (Team 24 - Bots'N'Stuff) For Providing the X-Drive Code  //
//																																									 //
///////////////////////////////////////////////////////////////////////////////////////
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	wait1Msec(2000);
	bMotorReflected[port2] = 1;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
const tSensors kGyroPort = in1; // gyroscopic sensor port/name
bool doUseGyro = true; // enable gyroscopic sensor
float gyroOffset = 90.0; // degrees CCW from +x axis robot faces at gyro=0
void calibrateGyro()
{
	// completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[kGyroPort] = sensorNone;
	wait1Msec(1000);
	SensorType[kGyroPort] = sensorGyro; // reconfigure as sensorGyro
	wait1Msec(2000); // wait for calibration: ROBOT MUST STAY STILL

	SensorScale[kGyroPort] = 138; // adjust SensorScale to correct the scaling for your gyro
	SensorFullCount[kGyroPort] = 3599; // fix rollover to be "...3598, 3599, 0, 1..."
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while(SensorValue[leftEncoder] < 500)//These numbers are counts, for every 90 counts is one rotation (i.e. 90 for a 4 inch wheel means the robot will move 4 inches)
	{
		if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
		{
			motor[port3] = 50;
			motor[port2] = 63;
		}
		if(SensorValue[leftEncoder] < SensorValue[rightEncoder])
		{
			motor[port3] = 63;
			motor[port2] = 50;
		}
		if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
		{
			motor[port3] = 63;
			motor[port2] = 63;
		}
	}
	SensorValue[leftEncoder] = 0;
	while(SensorValue[leftEncoder] < 70)//Turn right for 70 clicks or .78 of a wheel rotation
	{
		motor[port3] = -63;
		motor[port2] = 63;
	}
	SensorValue[leftEncoder] = 0;
	while(SensorValue[leftEncoder] < 270)//Straight for 3 rotations
	{
		motor[port3] = 63;
		motor[port2] = 63;
	}
	SensorValue[leftEncoder] = 0;
	while(SensorValue[leftEncoder] < 92)//Turn left for a little over 1 wheel rotation
	{
		motor[port3] = 63;
		motor[port2] = -63;
	}
	SensorValue[leftEncoder] = 0;
	while(SensorValue[leftEncoder] < 180)//Stragiht for two rotations
	{
		motor[port3] = 63;
		motor[port2] = 63;
	}
	SensorValue[leftEncoder] = 0;
	while(SensorValue[leftEncoder] < 93)//Turn left for a little over 1 wheel rotation
	{
		motor[port3] = 63;
		motor[port2] = -63;
	}
	SensorValue[leftEncoder] = 0;
	while(SensorValue[leftEncoder] < 140)//Straight for about 1.5 wheel rotations
	{
		motor[port3] = 63;
		motor[port2] = 63;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task userDriveHolo() {
  const TVexJoysticks kChY = Ch3; // y-axis joystick channel
  const TVexJoysticks kChX = Ch4; // x-axis joystick channel
  const TVexJoysticks kChR = Ch1; // rotation joystick channel
  const short kDelay = 25; // milliseconds for loop delay
  const ubyte kNumWheels = 4; // number of drive wheels
  const ubyte kNumMotorsPerWheel = 2; // max number of motors per wheel
  const tMotor kNone = -1; // used for indicating the lack of an additional motor
  const tMotor kMotorPort[kNumWheels][kNumMotorsPerWheel] = { // drive motor ports/names
    {leftFront, kNone}, // front-left
    {rightFront, kNone}, // front-right
    {leftRear, kNone}, // back-left
    {rightRear, kNone},  // back-right
  };
 word x,y,r;
  float gyro,radius,theta,a,b,wheelSpeed[kNumWheels],topSpeed;
	while (true)
	{// ==== collect joystick & sensor values ====
    x = vexRT[kChX]; // x component
    y = vexRT[kChY]; // y component
    r = vexRT[kChR]; // rotation
    gyro = gyroOffset + (doUseGyro ? SensorValue[kGyroPort]/10.0 : 0.0); // if using gyro, scale its value to degrees

    // ==== convert joystick values to polar ====
    radius = sqrt(pow(x,2) + pow(y,2)); // r = sqrt(x^2 + y^2)
    theta = atan2(y,x)*180.0/PI; // t = arctan(y/x) [converted from radians to degrees]

    theta -= gyro; // adjust for gyro angle

    // ==== calculate opposite-side speeds ====
    a = (cosDegrees(theta) - sinDegrees(theta))*radius; // front-left and back-right
    b = (cosDegrees(theta) + sinDegrees(theta))*radius; // front-right and back-left

    // ==== set speeds, including rotation ====
    wheelSpeed[0] = a + r; // front-left
    wheelSpeed[1] = b - r; // front-right
    wheelSpeed[2] = b + r; // back-left
    wheelSpeed[3] = a - r; // back-right

    // ==== normalize speeds ====
    topSpeed = 0.0;
    for(ubyte i=0; i<kNumWheels; i++)
      if(abs(wheelSpeed[i]) > topSpeed)
        topSpeed = abs(wheelSpeed[i]); // find highest desired speed
    if(topSpeed > 127.0)
      for(ubyte i=0; i<kNumWheels; i++)
        wheelSpeed[i] /= topSpeed/127.0; // downscale all speeds so none are above 127

    // ==== update motor powers ====
    for(ubyte i=0; i<kNumWheels; i++) // cycle through all wheels
      for(ubyte j=0; j<kNumMotorsPerWheel; j++) // cycle through all motors for each wheel
        if(kMotorPort[i][j] != kNone) // check existence of motor
          motor[kMotorPort[i][j]] = (word)wheelSpeed[i]; // update motor power

    wait1Msec(kDelay);
  }
}

task usercontrol()
{
	// User control code here, inside the loop

  calibrateGyro();
  startTask(userDriveHolo);

  while(true)
    wait1Msec(100);
}
